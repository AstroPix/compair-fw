
from cocotb.triggers    import Timer , RisingEdge , FallingEdge , Join , First ,Event
import vip.spi
vip.spi.info()

import logging 
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

import random

def debug():
    logger.setLevel(logging.DEBUG)


class Astropix3Model:
    """This Model can be used to return some bytes"""

    def __init__(self,dut,prefix,chipID):
        self.interruptn       = dut._id(prefix+"_interruptn", extended=False)
        self.interruptn.value = 1
        self.chipID           = chipID

        ## Create Slave VIP
        ## Create SPI Slave
        self.spiSlave = vip.spi.VSPISlave(
            clk = dut._id(prefix+"_spi_clk", extended=False), 
            csn = dut._id(prefix+"_spi_csn", extended=False),
            mosi= dut._id(prefix+"_spi_mosi", extended=False),
            miso= dut._id(prefix+"_spi_miso", extended=False),
            misoDefaultValue = 0x3D)
        self.spiSlave.misoDoneEvent = Event("spi_miso_done")
        self.spiSlave.start_monitor()

        ## Generated bytes
        self.generatedBytes = []
       

    ## Config
    ###################
    async def loadConfigFromYAML(self, srName: str ):
        """This method loads the list of SR config from YAML - A name must be provided since multiple SR chains can be available in the chip"""

    ## Frame generation
    ############
    #async def generateTestFrames(self,count:int,leng)
    async def generateTestFrame(self,length:int,framesCount: int = 1,isRandom:bool = False ,pause:bool=False): 
        """Generate a Frame of a certain length with a counter as value"""

        logger.info(f"[astropix] Starting frame generator, chip id={self.chipID}, queue length={self.spiSlave.misoQueue.qsize()}")
        try:

            self.generatedBytes = []

            ## Generate Bytes counter
            for frameI in range(framesCount):
                bytes = []

                # Generate header then bytes
                header = length | (self.chipID << 3)
                logger.debug(f"[astropix] frame header={hex(header)}")
                self.generatedBytes.extend([header])
                await self.spiSlave.misoQueue.put(header)
                for x in range(length):
                    byte = x+1 if (isRandom is False) else  random.randint(1,128)
                    self.generatedBytes.extend([byte])
                    await self.spiSlave.misoQueue.put(byte)

                # Generate Pause with some IDLE bytes
                if pause:
                    pauseLength = range(random.randint(0,10))
                    #logger.info(f"- Adding Pause of Length {pauseLength}")
                    for x in pauseLength:
                        await self.spiSlave.misoQueue.put(0x3D)

            ## Trigger interrupt
            self.interruptn.value = 0

            ## Wait until sending done
            try:
                await self.spiSlave.misoDoneEvent.wait()
                self.spiSlave.misoDoneEvent.clear()
            except:
                ## Clean queue
                #self.spiSlave.misoQueue._init()
                #print("Timedout finishing")
                for x in range(self.spiSlave.misoQueue.qsize()):
                    await self.spiSlave.misoQueue.get()
                #print("Cleared queue")
                #await self.spiSlave.misoQueue.clear()
                #pass
                #print("Wait for done timed out")
            finally:
                ## Release interrupt
                await Timer(random.randint(1,99),units="ns")
                self.interruptn.value = 1
        
        except Exception as e:
            logging.error(e)
        #print("Done frame generator")

    ## SPI Frames Analyses
    ##############
    async def parseSPIBytesAsConfig(self,broadcast : bool = False): 
        """Analyses the SPI Bytes as config command, throw an error if not a config"""
        if await self.spiSlave.getBytesCount() == 0:
            raise Error("No Bytes received as SPI Slave")
        
        
        # Check header
        ####
        header = await self.spiSlave.getByte()
        if broadcast is True:
            assert (header & 0x1F) == 0x1E , "Header address must be 0x1E Broadcast in broadcast mode"

        assert (header >> 5) == 0x3 , "Header Command bits must be 0x3 for SR Config"

        # Loop to get the config bits
        logger.info("Checking SPI Config SIN/CK1/CK2 sequence")
        res = []
        while await self.spiSlave.getBytesCount() >0:
            srByte = await self.spiSlave.getByte()

            # Check load
            if (srByte == 0x3):
                logger.info(f"-- Found Load")
                while await self.spiSlave.getBytesCount() >0:
                    srByte = await self.spiSlave.getByte()
                    if (srByte == 0x3):
                        logger.info(f"-- Found Load")
                    else:
                        break
                logger.info(f"-- End of Load")
                break 

            # SIN byte
            res.append(srByte & 0x01)
            logger.info(f"- SIN={srByte & 0x01}")


        await self.spiSlave.clearBytes()
        logger.info(f"-- Done SPI Config: {res}")
        return res


    ## SPI Frame Decoding
    ###########
    def decodeCheckASTEPFramesStaticLength(self,readBytes:bytes,framesCount:int,frameLength:int):
        """Checks that readout frames are correct, assuming the frame lenght was always the same"""
        logger.info("Checking received ASTEP frames against generated ones")
        expectedReadBytesLength = framesCount * (frameLength+1+4+2)
        assert(len(readBytes) == expectedReadBytesLength)

        # Params
        astropixFrameFullLength = frameLength +1
        frameHeaderLength = 1 + astropixFrameFullLength + 4   # Header length is the length of frame payload, excluding itself
        frameHeaderLayerId = 0
        
        # Loop through received bytes, and check headers and data
        finished = False
        i = 0
        generatedI = 0
        while not finished: 
            
            # Check Header
            currentByte = readBytes[i]
            i += 1
            logger.debug(f"- Frame Header Length: {currentByte}")
            assert(currentByte == frameHeaderLength)

            # Check Layer ID
            currentByte = readBytes[i]
            i += 1
            logger.debug(f"-- Frame Layer ID: {currentByte}")
            assert(currentByte == 1)

            # The next bytes are the astropix frame of size frameLength+1 (data length + header)
            astropixFrame = readBytes[i:i+astropixFrameFullLength]
            sourceAstropixFrame = self.generatedBytes[generatedI:generatedI+astropixFrameFullLength]
            i = i + astropixFrameFullLength
            generatedI = generatedI + astropixFrameFullLength

            logger.debug(f"-- Astropix data read={astropixFrame},generated={sourceAstropixFrame}")
            assert(astropixFrame == sourceAstropixFrame)

            ## The next 4 bytes are FPGA Timestamp, skip these as we can't check against known values
            i = i + 4

            if (i == len(readBytes)):
                finished = True